/* Generated by: CongoCC Parser Generator. Do not edit. BaseNode.java  */
package net.magneticpotato.sqlexpr.congocc.parser.ast;

import net.magneticpotato.sqlexpr.congocc.parser.*;
import static net.magneticpotato.sqlexpr.congocc.parser.Token.TokenType.*;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Collection;
import java.util.Collections;


/**
* The base concrete class for non-terminal Nodes
*/
public class BaseNode implements Node {
    private SqlExprParserLexer tokenSource;

    public SqlExprParserLexer getTokenSource() {
        if (tokenSource == null) {
            for (Node child : children()) {
                if (child.getTokenSource() instanceof SqlExprParserLexer) tokenSource = (SqlExprParserLexer) child.getTokenSource();
                if (tokenSource != null) break;
            }
        }
        return tokenSource;
    }

    public void setTokenSource(TokenSource tokenSource) {
        this.tokenSource = (SqlExprParserLexer) tokenSource;
    }

    private static Class<? extends List<Node>> listClass;

    /**
    * Sets the List class that is used to store child nodes. By default,
    * this is java.util.ArrayList. There is probably very little reason
    * to ever use anything else, though you could use this method
    * to replace this with LinkedList or your own java.util.List implementation even.
    * @param listClass the #java.util.List implementation to use internally
    * for the child nodes. By default #java.util.ArrayList is used.
    */
    public static void setListClass(Class<? extends List<Node>> listClass) {
        BaseNode.listClass = listClass;
    }

    private List<Node> newList() {
        if (listClass == null) {
            return new ArrayList<>();
        }
        try {
            return listClass.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
    * the parent node
    */
    private Node parent;
    /**
    * the child nodes
    */
    private final List<Node> children = newList();
    private int beginOffset, endOffset;
    private boolean unparsed;

    public boolean isUnparsed() {
        return this.unparsed;
    }

    public void setUnparsed(boolean unparsed) {
        this.unparsed = unparsed;
    }

    public void setParent(Node n) {
        parent = n;
    }

    public Node getParent() {
        return parent;
    }

    public boolean add(Node n) {
        n.setParent(this);
        return children.add(n);
    }

    public void add(int i, Node n) {
        children.add(i, n);
        n.setParent(this);
    }

    public Node get(int i) {
        return children.get(i);
    }

    public Node set(int i, Node n) {
        children.get(i).setParent(null);
        n.setParent(this);
        return children.set(i, n);
    }

    public Node remove(int i) {
        Node n = children.remove(i);
        n.setParent(null);
        return n;
    }

    public boolean remove(Object obj) {
        Node n = (Node) obj;
        n.setParent(null);
        return children.remove(n);
    }

    public void clear() {
        for (Node child : children) {
            child.setParent(null);
        }
        children.clear();
    }

    public int size() {
        return children.size();
    }

    public List<Node> children() {
        return Collections.unmodifiableList(children);
    }

    public int getBeginOffset() {
        return beginOffset;
    }

    public void setBeginOffset(int beginOffset) {
        this.beginOffset = beginOffset;
    }

    public int getEndOffset() {
        return endOffset;
    }

    public void setEndOffset(int endOffset) {
        this.endOffset = endOffset;
    }

    public List<Node> subList(int from, int to) {
        return children.subList(from, to);
    }

    public List<Token> getRealTokens() {
        return descendants(Token.class, t -> !t.isUnparsed());
    }

    public boolean addAll(Collection<? extends Node> nodes) {
        for (Node n : nodes)n.setParent(this);
        return children.addAll(nodes);
    }

    public boolean addAll(int i, Collection<? extends Node> nodes) {
        for (Node n : nodes)n.setParent(this);
        return children.addAll(i, nodes);
    }

    public boolean containsAll(Collection<?> nodes) {
        return children.containsAll(nodes);
    }

    public boolean retainAll(Collection<?> nodes) {
        return children.containsAll(nodes);
    }

    public boolean removeAll(Collection<?> nodes) {
        return children.removeAll(nodes);
    }

    public String toString() {
        return getSource();
    }

    private Map<String, Node> namedChildMap;
    private Map<String, List<Node>> namedChildListMap;

    public Node getNamedChild(String name) {
        if (namedChildMap == null) {
            return null;
        }
        return namedChildMap.get(name);
    }

    public void setNamedChild(String name, Node node) {
        if (namedChildMap == null) {
            namedChildMap = new HashMap<>();
        }
        if (namedChildMap.containsKey(name)) {
            // Can't have duplicates
            String msg = String.format("Duplicate named child not allowed: {0}", name);
            throw new RuntimeException(msg);
        }
        namedChildMap.put(name, node);
    }

    public List<Node> getNamedChildList(String name) {
        if (namedChildListMap == null) {
            return null;
        }
        return namedChildListMap.get(name);
    }

    public void addToNamedChildList(String name, Node node) {
        if (namedChildListMap == null) {
            namedChildListMap = new HashMap<>();
        }
        List<Node> nodeList = namedChildListMap.computeIfAbsent(name, k -> new ArrayList<>());
        nodeList.add(node);
    }

}


